#coding:utf-8

#辞書(写像)
#	A,Bを集合とするときに
#		A×B(AとBの直積)の部分集合をAとBの関係と呼ぶ
#	AとBの関係Rが次の性質を持つとき、Rは写像という
#		(a)for all a A exist b in B s.t. aRb
#		(b)if aRb land aRb'  -> b=b'
#
#
#Python
#	d={"abc":1,"efg":3}
#	は集合{"abc","efg"}から{1,3}を含むような集合への写像になっている
#
#
#辞書
#	内容的には、ついのリストのような形(表)
#	気持ち : upper = [('a','A'),('b','B'),...]
#		 upper('a') -> 'A'
#
#	入力と出力の型は自由に決められる。keyもvalueも任意の値を使える。listをkeyにすることもできるらしい.
#	keyの重複はゆるされない
#
#
#	「表」は有限集合を定義域とする関数の定義になる? つまり表を作るとは、関数を作ることである.
#	表を引く作業は関数の値の評価になっている
#	(ex)一桁の整数値(-9,...,9)上の二乗の関数sq
#		sq = {-9:81,...,9:81}
#
#
#	リスト(の要素)もそうだが、辞書(の値)も代入可能(英語ではミュータブル)
#		sq[-8]=-64 なんて上書きも出来る。
#
#	リストと辞書の操作
#		両方とも、長さが固定ではない
#			すべての要素を処理するには、繰り返しが必要
#				for文を使うことによって、すべての要素の処理が出来る。
#
#	(注意)keys() が返すリストの要素の順序は不定 : どういう順序かはわからない。
#	      嫌な場合は、リストをソートする。(l=[1,3,5,2,4,6]のとき、l.sort()でソートできる )
#
#
#
#
#
#


#辞書を作成する
d={"abc":2,"bcd":3}
#辞書のkeyに対する値を出力する
print d["abc"]
print d["bcd"]
#辞書のkeyだけを拾ってくる
print d.keys()

#値を後からの代入して追加,変更する例
sq = {-9:81}
print sq[-9]
sq[-9]=-81	#辞書のkey -9に対するvalue 81を-81に書き換え (-81を代入)	##辞書のvalueの代入の例
print sq[-9]

#すべての要素を変更する例
a = [-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]
for i in a:
	sq[i] = i*i

#すべての要素を出力する例
for i in sq.keys():
	print i," : ",sq[i]

print "\n"	#改行


#辞書をソートする
l = sq.keys()
l.sort()
print l
for i in l:
	print i," : ",sq[i]

##################################################################################
#単語の個数を数える
f = open('spams.txt')	#ファイルspams.txtに対するファイルポインタを取得し,fに代入
data = f.read()		#ファイルの内容をすべてまとめて読み込んでdataに入れている

#デバッグ
print 'DEBUG1=========================================='
print data		#ファイルの中身がすべて出ます
print '================================================'

#counting
words = {}		#辞書の初期化
for word in data.split():	#文字列を単語リストに変換する
	words[word] = words.get(word,0)+1
	#words[word] = words[word]+1で良さそうだがダメ。
	#	wordsの中にwordsの中にwordが登録されていない場合errorになるので
	#	こう書けば良い
	#	if word in words:
	#		words[word] = words[word]+1
	#	else:
	#		words[word] = 1
	#
	#	これの機能の省略形式が
	#		words[word] = words.get(word,0)+1
	#	で、dict.get(A,B)は
	#	Aがdictのキーの時には、dict[A]だが、そうでない場合は0になる

#デバッグ
print 'DEBUG2=========================================='
print data.split()
print '================================================'


#sort by count
for key in words.keys():
	print key, words[key]
